import fs from 'fs-extra'
import { exec, spawn, SpawnOptions, ExecOptions } from 'child_process'
import { format, Options as PrettierOptions } from 'prettier'

import { pathExists } from './utils'

export const runShell = async (
  cmd: string,
  options?: ExecOptions,
): Promise<string | Buffer> => {
  console.log('[CMD] ' + cmd)

  return await new Promise((resolve, reject) => {
    exec(
      cmd,
      {
        cwd: process.cwd(),
        ...options,
      },
      (
        error: Error | null,
        stdout: string | Buffer,
        stderr: string | Buffer,
      ) => {
        if (process.env.verbose === 'true') {
          console.log(stderr || stdout)
        }
        if (error) reject(error)
        resolve(stdout)
      },
    )
  })
}

export const spawnShell = async (
  cmd: string,
  options?: SpawnOptions,
): Promise<number> => {
  console.log('[CMD] ' + cmd)

  const [command, ...commandArguments] = cmd.split(' ')
  return await new Promise((resolve) =>
    spawn(command, commandArguments, {
      stdio: 'inherit',
      env: process.env,
      shell: true,
      cwd: process.cwd(),
      ...options,
    }).on('exit', (exitCode: number) => resolve(exitCode)),
  )
}

export const useYarn = async (): Promise<boolean> => {
  return await pathExists(process.cwd() + '/yarn.lock')
}

export const runPrisma = async (cmd: string, options?: SpawnOptions) => {
  const cmdStr =
    'npx prisma ' +
    (cmd.includes('migrate') || cmd.includes('studio')
      ? cmd + ' --experimental'
      : cmd)

  try {
    await spawnShell(cmdStr, options)
  } catch (err) {
    console.error(err)
    process.exit(1)
  }
}

export const formation = (
  text: string,
  parser: PrettierOptions['parser'] = 'babel',
  prefixStr: string = `/**
 * This file was generated by mrapi
 * Do not make changes to this file directly
 */`,
) => {
  return format(`${prefixStr}\n${text}`, {
    singleQuote: true,
    semi: false,
    trailingComma: 'all',
    tabWidth: 2,
    parser,
  })
}

export const readFileSync = (path: string) => {
  return fs.readFileSync(path, 'utf8')
}

export const writeFileSync = (path: string, content: string) => {
  return fs.outputFileSync(path, content)
}
